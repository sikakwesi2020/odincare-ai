import { Activity } from '../models/Activity';
import { TerraDataResponse } from './Data';
import { TerraAthleteResponse } from './Athlete';
import { TerraWidgetResponse } from './GenerateWidgetSessions';
import { TerraAuthTokenResponse } from './GenerateAuthToken';
import { TerraProvidersResponse } from './Providers';
import { TerraSubscriptionsResponse } from './Subscribers';
import { TerraUserResponse } from './UserInfo';
import { Body } from '../models/Body';
import { Sleep } from '../models/Sleep';
import { Daily } from '../models/Daily';
import { Nutrition } from '../models/Nutrition';
import { Menstruation } from '../models/Menstruation';
import { TerraAuthUserResponse } from './AuthUser';
export default class Terra {
    private devID;
    private apiKey;
    private secret;
    private mutex;
    constructor(devID: string, apiKey: string, secret: string);
    /**
     * Generate an Auth Token to be used with the SDK initialization
     *
     * @returns {Promise<TerraAuthTokenResponse>} A promise of type Auth Token Response
     */
    generateAuthToken(): Promise<TerraAuthTokenResponse>;
    /**
     * Generate an Auth URL to be authenticate a user
     *
     * @param {string} referenceID - Terra user ID
     * @param {string} resource - Wearable provider
     * @param {string} language - Language the widget page is showed in
     * @param {string} authSuccessRedirectUrl - Redirect URL when the session succeeds
     * @param {string} authFailureRedirectUrl - Redirect URL when the session fails
     * @param {string} facilityId - Facility ID for applicable resource (e.g. INBODY)
     *
     * @returns {Promise<TerraAuthUserResponse>} A promise of type Authenticate User Response
     */
    authUser(params: {
        resource: string;
        referenceId?: string;
        language?: string;
        authSuccessRedirectUrl?: string;
        authFailureRedirectUrl?: string;
        facilityId?: string;
    }): Promise<TerraAuthUserResponse>;
    /**
     * Generate a widget session
     *
     * @param {string} referenceID - Terra user ID
     * @param {string[]} providers - Array of strings for wearable providers
     * @param {string} language - Language the widget page is showed in
     * @param {string} authSuccessRedirectUrl - Redirect URL when the session succeeds
     * @param {string} authFailureRedirectUrl - Redirect URL when the session fails
     * @param {boolean} showDisconnect - Show disconnect button on widget for same reference ID
     *
     * @returns {Promise<TerraWidgetResponse>} A promise of type Widget Response
     */
    generateWidgetSession(params: {
        referenceID: string;
        language: string;
        providers?: string[];
        authSuccessRedirectUrl?: string;
        authFailureRedirectUrl?: string;
        showDisconnect?: boolean;
    }): Promise<TerraWidgetResponse>;
    /**
     * Get available Terra providers
     *
     * @return {Promise<TerraProvidersResponse>} A promise of type Providers
     *
     */
    getProviders(): Promise<TerraProvidersResponse>;
    /**
     * Get all subscribed users
     *
     * @return {Promise<TerraSubscriptionsResponse>} A promise of type Subscriptions
     *
     */
    getUsers(): Promise<TerraSubscriptionsResponse>;
    /**
     * Get information about a Terra user
     *
     * @param {string} userID - Terra user ID
     *
     * @return {Promise<TerraUserResponse>} A promise of type User
     *
     */
    getUser(params: {
        userID?: string;
        referenceID?: string;
    }): Promise<TerraUserResponse>;
    /**
     * Deauthenticate Terra user
     *
     * @param {string} userID - Terra user ID
     *
     * @return {Promise<void>} A promise fulfilled when deauth succeeds
     *
     */
    deauthUser(userID: string): Promise<void>;
    private getDataWrapper;
    /**
     * Get Athlete data for current user
     * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
     *
     * @return {Promise<TerraAthleteResponse>} A promise of type Athlete Data
     *
     */
    getAthlete(params: {
        userId: string;
        toWebhook?: boolean;
    }): Promise<TerraAthleteResponse>;
    /**
     * Get Activity data for current user
     * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
     * @param {Date} startDate - Start date for the date range limit
     * @param {Date} endDate - End date for the date range limit
     * @param {boolean} withSamples - True for getting samples and false for only getting summaries
     * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
     * @return {Promise<TerraDataResponse<Activity>>} A promise of type Activity Data
     *
     */
    getActivity: (params: {
        userId: string;
        startDate: Date;
        endDate?: Date;
        toWebhook?: boolean;
        withSamples?: boolean;
        retryIfRateLimited?: boolean;
    }) => Promise<TerraDataResponse<Activity>>;
    /**
     * Get Body data for current user
     * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
     * @param {Date} startDate - Start date for the date range limit
     * @param {Date} endDate - End date for the date range limit
     * @param {boolean} withSamples - True for getting samples and false for only getting summaries
     * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
     * @return {Promise<TerraDataResponse<Body>>} A promise of type Body Data
     *
     */
    getBody: (params: {
        userId: string;
        startDate: Date;
        endDate?: Date;
        toWebhook?: boolean;
        withSamples?: boolean;
        retryIfRateLimited?: boolean;
    }) => Promise<TerraDataResponse<Body>>;
    /**
     * Get Daily data for current user
     * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
     * @param {Date} startDate - Start date for the date range limit
     * @param {Date} endDate - End date for the date range limit
     * @param {boolean} withSamples - True for getting samples and false for only getting summaries
     * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
     * @return {Promise<TerraDataResponse<Daily>>} A promise of type Daily Data
     *
     */
    getDaily: (params: {
        userId: string;
        startDate: Date;
        endDate?: Date;
        toWebhook?: boolean;
        withSamples?: boolean;
        retryIfRateLimited?: boolean;
    }) => Promise<TerraDataResponse<Daily>>;
    /**
     * Get Sleep data for current user
     * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
     * @param {Date} startDate - Start date for the date range limit
     * @param {Date} endDate - End date for the date range limit
     * @param {boolean} withSamples - True for getting samples and false for only getting summaries
     * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
     * @return {Promise<TerraDataResponse<Sleep>>} A promise of type Sleep Data
     *
     */
    getSleep: (params: {
        userId: string;
        startDate: Date;
        endDate?: Date;
        toWebhook?: boolean;
        withSamples?: boolean;
        retryIfRateLimited?: boolean;
    }) => Promise<TerraDataResponse<Sleep>>;
    /**
     * Get Nutrition data for current user
     * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
     * @param {Date} startDate - Start date for the date range limit
     * @param {Date} endDate - End date for the date range limit
     * @param {boolean} withSamples - True for getting samples and false for only getting summaries
     * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
     * @return {Promise<TerraDataResponse<Nutrition>>} A promise of type Nutrition Data
     *
     */
    getNutrition: (params: {
        userId: string;
        startDate: Date;
        endDate?: Date;
        toWebhook?: boolean;
        withSamples?: boolean;
        retryIfRateLimited?: boolean;
    }) => Promise<TerraDataResponse<Nutrition>>;
    /**
     * Get Menstruation data for current user
     * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
     * @param {Date} startDate - Start date for the date range limit
     * @param {Date} endDate - End date for the date range limit
     * @param {boolean} withSamples - True for getting samples and false for only getting summaries
     * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
     * @return {Promise<TerraDataResponse<Menstruation>>} A promise of type Menstruation Data
     *
     */
    getMenstruation: (params: {
        userId: string;
        startDate: Date;
        endDate?: Date;
        toWebhook?: boolean;
        withSamples?: boolean;
        retryIfRateLimited?: boolean;
    }) => Promise<TerraDataResponse<Menstruation>>;
    /**
     * Checks webhook signature
     * @param {string} terraSignature - Terra signature string found in header of request sent to webhook endpoint
     * @param {ReqBody} payload - Body of request sent to webhook endpoint
     * @param {string} secret - Signing secret used to verify webhook
     * @return {Boolean} - A boolean, true if the signature is valid
     *
     */
    checkTerraSignature(terraSignature: string, payload: string): boolean;
    /**
     * Synchronises a set of functions. It is meant to be used to handle webhooks if
     * the infrastructure could face race conditions
     * @param {(...args: any[]) => void} callback - Function to be executed, usually the webhook handler
     * @param {any[]} args - Extra arguments passed to the handler, usually the request contents
     */
    executeSynchronously(callback: (...args: any[]) => void, ...args: any[]): void;
}
