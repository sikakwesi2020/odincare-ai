"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Data_1 = require("./Data");
const Athlete_1 = require("./Athlete");
const GenerateWidgetSessions_1 = require("./GenerateWidgetSessions");
const GenerateAuthToken_1 = require("./GenerateAuthToken");
const Providers_1 = require("./Providers");
const Subscribers_1 = require("./Subscribers");
const UserInfo_1 = require("./UserInfo");
const Helpers_1 = require("./Helpers");
const AuthUser_1 = require("./AuthUser");
const async_mutex_1 = require("async-mutex");
class Terra {
    constructor(devID, apiKey, secret) {
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Get Activity data for current user
         * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
         * @param {Date} startDate - Start date for the date range limit
         * @param {Date} endDate - End date for the date range limit
         * @param {boolean} withSamples - True for getting samples and false for only getting summaries
         * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
         * @return {Promise<TerraDataResponse<Activity>>} A promise of type Activity Data
         *
         */
        this.getActivity = this.getDataWrapper('activity');
        /**
         * Get Body data for current user
         * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
         * @param {Date} startDate - Start date for the date range limit
         * @param {Date} endDate - End date for the date range limit
         * @param {boolean} withSamples - True for getting samples and false for only getting summaries
         * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
         * @return {Promise<TerraDataResponse<Body>>} A promise of type Body Data
         *
         */
        this.getBody = this.getDataWrapper('body');
        /**
         * Get Daily data for current user
         * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
         * @param {Date} startDate - Start date for the date range limit
         * @param {Date} endDate - End date for the date range limit
         * @param {boolean} withSamples - True for getting samples and false for only getting summaries
         * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
         * @return {Promise<TerraDataResponse<Daily>>} A promise of type Daily Data
         *
         */
        this.getDaily = this.getDataWrapper('daily');
        /**
         * Get Sleep data for current user
         * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
         * @param {Date} startDate - Start date for the date range limit
         * @param {Date} endDate - End date for the date range limit
         * @param {boolean} withSamples - True for getting samples and false for only getting summaries
         * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
         * @return {Promise<TerraDataResponse<Sleep>>} A promise of type Sleep Data
         *
         */
        this.getSleep = this.getDataWrapper('sleep');
        /**
         * Get Nutrition data for current user
         * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
         * @param {Date} startDate - Start date for the date range limit
         * @param {Date} endDate - End date for the date range limit
         * @param {boolean} withSamples - True for getting samples and false for only getting summaries
         * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
         * @return {Promise<TerraDataResponse<Nutrition>>} A promise of type Nutrition Data
         *
         */
        this.getNutrition = this.getDataWrapper('nutrition');
        /**
         * Get Menstruation data for current user
         * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
         * @param {Date} startDate - Start date for the date range limit
         * @param {Date} endDate - End date for the date range limit
         * @param {boolean} withSamples - True for getting samples and false for only getting summaries
         * @param {boolean} retryIfRateLimited - True for retrying if rate limited and false for not retrying
         * @return {Promise<TerraDataResponse<Menstruation>>} A promise of type Menstruation Data
         *
         */
        this.getMenstruation = this.getDataWrapper('menstruation');
        (0, Helpers_1.checkForServerSideAndWarn)();
        this.devID = devID;
        this.apiKey = apiKey;
        this.secret = secret;
    }
    /**
     * Generate an Auth Token to be used with the SDK initialization
     *
     * @returns {Promise<TerraAuthTokenResponse>} A promise of type Auth Token Response
     */
    generateAuthToken() {
        return (0, GenerateAuthToken_1.GenerateAuthToken)(this.devID, this.apiKey);
    }
    /**
     * Generate an Auth URL to be authenticate a user
     *
     * @param {string} referenceID - Terra user ID
     * @param {string} resource - Wearable provider
     * @param {string} language - Language the widget page is showed in
     * @param {string} authSuccessRedirectUrl - Redirect URL when the session succeeds
     * @param {string} authFailureRedirectUrl - Redirect URL when the session fails
     * @param {string} facilityId - Facility ID for applicable resource (e.g. INBODY)
     *
     * @returns {Promise<TerraAuthUserResponse>} A promise of type Authenticate User Response
     */
    authUser(params) {
        return (0, AuthUser_1.AuthUser)(this.devID, this.apiKey, params.resource, params.referenceId, params.language, params.authSuccessRedirectUrl, params.authFailureRedirectUrl, params.facilityId);
    }
    /**
     * Generate a widget session
     *
     * @param {string} referenceID - Terra user ID
     * @param {string[]} providers - Array of strings for wearable providers
     * @param {string} language - Language the widget page is showed in
     * @param {string} authSuccessRedirectUrl - Redirect URL when the session succeeds
     * @param {string} authFailureRedirectUrl - Redirect URL when the session fails
     * @param {boolean} showDisconnect - Show disconnect button on widget for same reference ID
     *
     * @returns {Promise<TerraWidgetResponse>} A promise of type Widget Response
     */
    generateWidgetSession(params) {
        return (0, GenerateWidgetSessions_1.GenerateWidgetSession)(this.devID, this.apiKey, params.referenceID, params.language, params.providers, params.authSuccessRedirectUrl, params.authFailureRedirectUrl, params.showDisconnect);
    }
    /**
     * Get available Terra providers
     *
     * @return {Promise<TerraProvidersResponse>} A promise of type Providers
     *
     */
    getProviders() {
        return (0, Providers_1.GetProviders)();
    }
    /**
     * Get all subscribed users
     *
     * @return {Promise<TerraSubscriptionsResponse>} A promise of type Subscriptions
     *
     */
    getUsers() {
        return (0, Subscribers_1.GetSubscribers)(this.devID, this.apiKey);
    }
    /**
     * Get information about a Terra user
     *
     * @param {string} userID - Terra user ID
     *
     * @return {Promise<TerraUserResponse>} A promise of type User
     *
     */
    getUser(params) {
        return (0, UserInfo_1.GetUser)(this.devID, this.apiKey, params.userID, params.referenceID);
    }
    /**
     * Deauthenticate Terra user
     *
     * @param {string} userID - Terra user ID
     *
     * @return {Promise<void>} A promise fulfilled when deauth succeeds
     *
     */
    deauthUser(userID) {
        return (0, UserInfo_1.DeauthUser)(this.devID, this.apiKey, userID);
    }
    // Data getters
    getDataWrapper(type) {
        return (params) => {
            return (0, Data_1.GetData)(type, this.devID, this.apiKey, params.userId, params.startDate, params.endDate, params.toWebhook, params.withSamples, params.retryIfRateLimited);
        };
    }
    /**
     * Get Athlete data for current user
     * @param {boolean} toWebhook - True for sending data to webhook and false for sending data in response body
     *
     * @return {Promise<TerraAthleteResponse>} A promise of type Athlete Data
     *
     */
    getAthlete(params) {
        return (0, Athlete_1.GetAthlete)(this.devID, this.apiKey, params.userId, params.toWebhook);
    }
    /**
     * Checks webhook signature
     * @param {string} terraSignature - Terra signature string found in header of request sent to webhook endpoint
     * @param {ReqBody} payload - Body of request sent to webhook endpoint
     * @param {string} secret - Signing secret used to verify webhook
     * @return {Boolean} - A boolean, true if the signature is valid
     *
     */
    checkTerraSignature(terraSignature, payload) {
        return (0, Helpers_1.CheckTerraSignature)(terraSignature, payload, this.secret);
    }
    /**
     * Synchronises a set of functions. It is meant to be used to handle webhooks if
     * the infrastructure could face race conditions
     * @param {(...args: any[]) => void} callback - Function to be executed, usually the webhook handler
     * @param {any[]} args - Extra arguments passed to the handler, usually the request contents
     */
    executeSynchronously(callback, ...args) {
        this.mutex.acquire().then((release) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield callback(...args);
                release();
            }
            catch (e) {
                release();
            }
        }));
    }
}
exports.default = Terra;
